import argparse
import pandas as pd
import numpy as np
from decimal import Decimal
from tree_scorer import log_prob_mat_mul_calc, log_pf_cond_mat_mul, log_pf_cond_numpy, log_pf_cond_on_one_tree

def partition_function(path_matrix, path_trees, alpha, beta, clade=None, mutation=None, path_list=None, path_scoring_matrix=None, gpu=False):
    df = pd.read_csv(path_matrix, sep="\t", index_col=[0])

    # Here we create the matrix representing the probability distribution of the ground truth,
    #   i.e. the entry i,j is the probability that entry i,j of the ground truth matrix equals 1,
    #   given the observed input genotype matrix stored in df
    I_mtr = df.values # I_mtr is the observed genotype matrix (0 if a mutation was called as absent, 1 if a mutation was present, 3 represents missing data)
    t1 = I_mtr * (1 - beta) / (alpha + 1 - beta) # If a 1 was observed, then the probability that the ground truth is 1 is equal to (1 - beta) / (alpha + 1 - beta)
    t2 = (1 - I_mtr) * beta / (beta + 1 - alpha) # If a 0 was observed, then the probability that the ground truth is 1 is equal to beta / (beta + 1 - alpha)
    P = t1 + t2
    P[I_mtr == 3] = 0.5                          # if a 3 (N/A entry) is observed we assume that there is a 50% probability that the entry is a 1
    
    logP1 = np.log2(P)
    logP0 = np.log2(1 - P)
    
    numerator = Decimal(0)
    denominator = Decimal(0)

    
    pairs = None
    if path_scoring_matrix != None:
        scoring_df = pd.read_csv(path_scoring_matrix, sep="\t", index_col=[0])
        pairs = np.empty(len(scoring_df.columns), dtype=object)
        for i in range(len(scoring_df.columns)):
            col = scoring_df[scoring_df.columns[i]]
            pairs[i] = ([c for c in col.keys() if col[c] == 1], scoring_df.columns[i])
    elif path_list != None:
        pass #implement later
    else:
        pairs = [clade.split(','), mutation]

    numerators = np.full(len(pairs), Decimal(0), dtype=object)
    num_cells = P.shape[0]
    with open(path_trees, 'r') as file:
        for line in file:
            line = line.strip()
            split = line.split(" ")
            log_sampling_prob = np.log2(np.float64(split[0]))
            subtrees = np.zeros(shape=(2 * num_cells, num_cells), dtype='bool')
            for idx in range(len(split[1])):
                subtrees[np.unravel_index(idx, subtrees.shape)] = bool(int(split[1][idx]))

            log_p1 = log_prob_mat_mul_calc(logP1, logP0, subtrees)
            denominator += 2 ** Decimal(log_p1 - log_sampling_prob)

            for i in range(len(numerators)):
                cell_ids = [list(df.index).index(cell) for cell in pairs[i][0]]
                cells_vec = np.zeros(P.shape[0], dtype='bool')
                cells_vec[cell_ids] = 1
                mut_id = list(df.columns).index(pairs[i][1])

                # log_p2 = log_pf_cond_on_one_tree(P, subtrees, cells_vec, mut_id)
                # log_p2 = log_pf_cond_mat_mul(P, subtrees, cells_vec, mut_id)
                log_p2 = log_pf_cond_numpy(P, subtrees, cells_vec, mut_id)

                numerators[i] += 2 ** Decimal(log_p1 + log_p2 - log_sampling_prob)

    for numerator in numerators:
        print(np.float64(numerator / denominator))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Partition function')

    #required args
    parser.add_argument("-i", "--input_matrix", type=str,                                                        
                        help="Path to input genotype matrix where rows correspond to cells/sublines and columns correspond to mutations. See repo examples for formatting.", required=True)
    parser.add_argument("-t", "--trees", type=str,                                                        
                        help="Path to file of trees generated by sampler.py", required=True)
    parser.add_argument("-fp", "--alpha", type=float,                                                        
                        help="False-positive rate (alpha in the paper)", required=True)
    parser.add_argument("-fn", "--beta", type=float,                                                        
                        help="False-negative rate (beta in the paper)", required=True)
    
    #optional args
    parser.add_argument("-g", "--gpu",
                        help="Runs probability computations on GPUs", action='store_true')
    
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-l", "--list", type=str,   
                        help="Path to file containing clades and mutations to compute partition function for. See GitHub repo example for format")
    group.add_argument("-sm", "--scoring_matrix", type=str,   
                        help="Path to binary matrix of same dimensions, row labels, and column labels as the input matrix. The genotype of each ")
    group.add_argument("-cm", "--clade_mut_pair", nargs=2, metavar=("CLADE", "MUTATION"), help="Clade and mutation")
    
    args = parser.parse_args()
    if args.scoring_matrix is not None:
        partition_function(args.input_matrix, args.trees, args.alpha, args.beta, path_scoring_matrix=args.scoring_matrix, gpu=args.gpu)
    else:
        pass # TODO implement this